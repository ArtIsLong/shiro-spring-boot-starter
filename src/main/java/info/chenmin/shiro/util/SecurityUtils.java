/** * $Id: SecurityUtil.java,v 1.0 2019-01-21 14:27 chenmin Exp $ * <p> */package info.chenmin.shiro.util;import lombok.extern.slf4j.Slf4j;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.subject.SimplePrincipalCollection;import org.apache.shiro.subject.Subject;import org.springframework.beans.BeanUtils;import org.springframework.util.ObjectUtils;import java.lang.reflect.ParameterizedType;/** * @author chenmin * @version $Id: SecurityUtil.java,v 1.1 2019-01-21 14:27 chenmin Exp $ * Created on 2019-01-21 14:27 */@Slf4jpublic class SecurityUtils extends org.apache.shiro.SecurityUtils {    /**     * 通用登录     * @param userName     * @param password     * @return     * @throws RuntimeException     */    public static Subject login(String userName, String password) throws RuntimeException {        Subject subject = getSubject();        UsernamePasswordToken token = new UsernamePasswordToken(userName, password);        // 登录        subject.login(token);        if (subject.isAuthenticated()) {            return subject;        }        return null;    }    public static <T> T getCurrentUser(Class<T> t) {        Object principal = getSubject().getPrincipal();        if (!ObjectUtils.isEmpty(principal)) {            return (T) principal;        }        return null;    }    public static <T> T updateSubject(T newUser) {        Subject subject = getSubject();        T oldUser = getCurrentUser(getClazz(newUser));        BeanUtils.copyProperties(newUser, oldUser);        PrincipalCollection principalCollection = subject.getPrincipals();        String realmName = principalCollection.getRealmNames().iterator().next();        PrincipalCollection newPrincipalCollection = new SimplePrincipalCollection(oldUser, realmName);        //重新加载Principal        subject.runAs(newPrincipalCollection);        return newUser;    }    private static <T> Class<T> getClazz(T t) {        // 获取当前new的对象的泛型的父类类型        ParameterizedType pt = (ParameterizedType) t.getClass().getGenericSuperclass();        // 获取第一个类型参数的真实类型        return  (Class<T>) pt.getActualTypeArguments()[0];    }}